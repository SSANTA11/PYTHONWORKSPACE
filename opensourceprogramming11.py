# 특수형 자료구조
    # 특수형은 시퀸스형과 다르게 순서 無

# 딕션너리
    # 메소드가 있든 없든 추가가능 
    # 수정이 가능함!!
    # 키와 값으로 이루어짐
        # 키와 값= 아이템
    # 키와 값은 일대일 대응이다.
    # 키는 유일하다.
    # 당연히 값은 중복가능하다.

# d={1:"a",2:"b",3:"c"}
# print(d)
# d={"a":1,"b":2,"c":3}
# print(d)

# d["a"]=11
# print(d["a"])

# d={"사번":1000,"이름":"홍길동","부서":"국악"}
# d["연봉"]=5000
# print(d)

# 중괄호 리스트
    # f={}
    # 혹은
    # f=dict()

# set??'***************************review
    # 중괄호를 사용한다....

#리 dict(함수로)함수로 딕션너리 만드는 여러 가지 방법
    # d=dict({"a":1,"b":2})
    # print(d)
    # d=dict([("a",1),["b",2]])
    # print(d)

    # d=dict(a=1,b=2)->왼쪽은 반드시 문자열 드러나 문자열에는 따옴표가 없음
    # print(d)

    # zip?*****************

        # dict(zip(('a','b')))

# keys=['a','b','c']
# d=dict.fromkeys(keys,0)***********************************************************review
# print(d)

# # 딕션널이의 메서드들


#     keys->키만 나온다
#     values->값만 나온다
#     items->키와 값이 '튜플'의 형태로 묶여서 나온다

    # d={"a":1,"b":2,"c":3}
    # if 3 in d:
    #     print("yes")
    # else:
    #     print("no")

    # d={"a":1,"b":2,"c":3}
    # for k,v in d.items():->언패킹(튜플이 각각의 변수로 ~~)
        # print(f"{k}:{v}")


#     get
# d={"a":1,"b":2,"c":3}
# print(d.get("a"))
# ********************************************get은 pop과 다르게 다르게 딕션너리 내부의 원소가 삭제되지 않는다*****************************


#     pop
# 딕션너리 값 가져오기
    # pop(키)->값을 리턴해준다

#     popitem
    # 아이템을 pop-> 고로 키가 없다.(?)->그래서 마지막 아이템을 가져옴(?)***************
        # d={"a":1,"b":2,"d":4,"c":3}
        # print(d.popitem())

#     setdefault
    # 딕션너리에 item 넣기
    # setdefault(키[,값])'
    # d={"a":1,"b":2,"d":4}
    # d.setdefault("c",3)
    # print(d)    
    # d={"a":1,"b":2,"d":4}
    # d.setdefault("c")
    # print(d)

#     update(기존값을 수정하거나 추가할 떄 사용가능)*********************형태 활용 이해 및 암기
    # 딕션너리에 item 넣기


#     clear


# 더 있지만 위 내용들이 딕션너리 메서드의 기본 !! 암기하자






# 패킹과 언패킹
    # 패킹: 포장하기-> 리스트 딕션너리 만들기
        # "*"를 사용하는 패킹: ->함수의 매개변수에 관련하여 사용된다.
            # 예) a,*b,c=[1,2,3,4,5,6,7]
            # print(b)-> [2,3,4,5,6]
    # 언패킹: 포장풀기->
        # 할당: 
        # a,b,c=a_list
        # ~~
    
        # k,v~~

        # 별표사용
            # 리스트와 튜플은 단일 원소구조임으로 별표한개
            # 딕션너리는 별표 두개
            # a=[1,2,3]
            # print(a)
            # print(*a)
            # print(range(5))*******************************************직접해보기
            # print(*range(5))******************************************직접해보기
            # print(*dic)-> 키 도출
            # print(**dic)-> print에서 반드시 오류 발생


                                                                                                                            # 인수(argument)는 종류가 두가지
                                                                                                                            #     키워드 인수, 포지션널 인수

# 딕션너리의 깊이있는 이해
    # item: 키와 값의 쌍->다른 자료구조의 원소에 해당

    # 이차원 리스트와 딕션너리의 차이 이해
        # 이차원리스트: 두개의 데이터 쌍
        # 딕션너리: 상품과 가격표
            # 분기별 상품가격은 딕션어리 內 키에 대응하는 값에 리스트 할당

    # 키에 올 수 있는 것-> 바뀌지 않는 것->튜플 가능/리스트 불가능/....
        # 키는 불가능하지만 값에는 딕션너리가 올 수 있다. 딕션너리를 값으로 갖는 중첩 딕션너리도 가능하다.
            # 값을 찾을 떄는 중첩 리스트의 인덱싱과 유사하게 사용가능하다.
# **********************************************딕션너리 시험100000000000000000000000000000% 출제*************************************************





# 세트
    # 수학에서의 집합구조를 구현한 자료형
    # 중괄호 사용
    # 세트에선 중복되는 원소는 존재하지 않는다.
    # 인덱싱이 안된다.
    # 원소에는 순서가 없다
    # 세트 자체는 수정가능 (원소자체는 수정 불가능)

# 리스트를 세트에 넣으면 중복된 숫자가 사라지고 세트로 변환되며 이후에 len을 이용할 수 있다.
# set가 3,2,1 과1,2,3 모두가 1,2,3으로 나오는 것은 순서가 있는 것은 아니다(그냥 시스템 상(?) 한계(?))
a=[3,2,1]
print(set(a))
# set의 기능은 직접 심화로 공부*********************************************************************
# unhashable은 시험에는 나오지 않지만 한번 볼것
# 오늘 수업 파일
# 컴퓨터 자료구조 파일
    # 참조-> 어떤 메모리 번수를 레퍼러싱한 것-> 모든 객체를 가르키는(?) 파이썬의 특징
    # 복사-> 
            # 딥카피!!!